library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity contador_monedas is
 port(
        clk            : in  std_logic;
        edge_monedas   : in  std_logic; -- flanco que indica que la moneda se ha metido
        edge_confir    : in  std_logic; -- boton de confirmar el pago cuando se hayan metido todas las monedas
        monedas        : in  std_logic_vector(3 downto 0); -- vector que representa qué moneda se ha metido (10, 20, 50, 1€)
        estado         : in  unsigned(2 downto 0); -- Entrada de la FSM que indica el estado global
        Reset_Contador : in std_logic ;

        faltan_monedas_contador : out unsigned(3 downto 0); -- Número de monedas que falta, de cara al DISPLAY para que pueda mostrarlo por pantalla
        ok             : out std_logic; -- Señal para la FSM de que el pago se ha podido realizar correctamente
        error          : out std_logic -- Señal para la FSM de que el pago ha sido erroneo, por pasarse o quedarse corto con el importe
    );
end contador_monedas;

architecture Behavioral of contador_monedas is

  signal faltan_reg : unsigned(3 downto 0) := to_unsigned(10, 4);
  signal resta      : unsigned(3 downto 0);
  signal ok_s         : std_logic := '0' ;
  signal error_s      : std_logic:= '0' ;

begin

   CONTADOR: process(clk, Reset_Contador) -- *** CORRECCIÓN 1: Agregar Reset_Contador a la lista de sensibilidad ***
    begin
        
        -- *** CORRECCIÓN 2: Manejo del Reset Asíncrono con prioridad ***
        if Reset_Contador = '1' then 
            faltan_reg <= to_unsigned(10, 4);
            ok_s    <= '0';
            error_s <= '0';
        
        elsif rising_edge(clk) then

            -- LÓGICA DE REINICIO SÍNCRONO (Estado 0 = "000")
            if estado = "000" then
                faltan_reg <= to_unsigned(10, 4);
                ok_s    <= '0';
                error_s <= '0';
            end if; 

            -- LÓGICA DE OPERACIÓN (solo si estamos en el ESTADO 1 = "001")
            if estado = "001" then

                    -- inserción de moneda
                    if edge_monedas = '1' then

                        resta <= (others => '0');

                        -- Lógica para determinar el valor de la resta
                        if monedas(0) = '1' then
                            resta <= to_unsigned(1, 4);
                        elsif monedas(1) = '1' then
                            resta <= to_unsigned(2, 4);
                        elsif monedas(2) = '1' then
                            resta <= to_unsigned(5, 4);
                        elsif monedas(3) = '1' then
                            resta <= to_unsigned(10, 4);
                        end if;


                        if faltan_reg > resta then
                            faltan_reg <= faltan_reg - resta;
                        elsif faltan_reg = resta then
                            faltan_reg <= (others => '0');
                        else
                            faltan_reg <= to_unsigned(15, 4); -- Se mantiene 20 por ahora
                        end if;

                    -- Si se le da a pagar y se ha pagado todo (faltan =0) entonces damos un OK,
                    -- si nos hemos pasado o nos hemos quedado cortos mandamos un error
                    elsif edge_confir = '1' then -- BOTON DE PAGAR
                        if faltan_reg = 0 then
                            ok_s <= '1'; 
                            error_s <= '0'; -- mensaje de ok que nos llevaria al estado 2 (EXPRENDER PRODUCTO)
                        else
                            ok_s <= '0'; 
                            error_s <= '1'; -- mensaje de error que nos llevaria al estado 4 (Error Pago)
                        end if;
                    end if;
            end if; -- Fin de if estado = "001"
        end if; -- Fin de if rising_edge(clk)
    end process;
    
    -- *** ELIMINACIÓN DEL PROCESO 'RESEET' CONFLICTIVO ***
    -- *** CORRECCIÓN 3: Uso de asignaciones concurrentes condicionales (WHEN/ELSE) para manejar el reset en las salidas ***
    
    -- La salida se resetea a "0000" si Reset_Contador es '1', si no, toma el valor del registro interno.
    faltan_monedas_contador <= (others => '0') WHEN Reset_Contador = '1' ELSE faltan_reg;
    
    -- La salida 'ok' se resetea a '0' si Reset_Contador es '1', si no, toma el valor de la señal interna ok_s.
    ok <= '0' WHEN Reset_Contador = '1' ELSE ok_s;
    
    -- La salida 'error' se resetea a '0' si Reset_Contador es '1', si no, toma el valor de la señal interna error_s.
    error <= '0' WHEN Reset_Contador = '1' ELSE error_s;

end Behavioral;

